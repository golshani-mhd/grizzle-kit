package types

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/golshani-mhd/grizzle-kit/flavors"
	"github.com/golshani-mhd/grizzle-kit/mapping"
)

// Table represents a database table.
type Table struct {
	Name    string
	Columns []*Column[any]
}

// getTypeWithAuto returns the SQL type with auto-increment if applicable.
func getTypeWithAuto(flavor flavors.Flavor, col *Column[any]) string {
	mappingFlavor := mapping.Flavor(flavor)
	sqlType := mapping.GetSQLType(mappingFlavor, col)
	if !col.AutoIncrement {
		return sqlType
	}
	autoTypes := []ColumnType{ColumnTypeTinyInt, ColumnTypeSmallInt, ColumnTypeInt, ColumnTypeBigInt}
	found := false
	for _, t := range autoTypes {
		if col.AbstractType == t {
			found = true
			break
		}
	}
	if !found {
		panic("auto-increment only supported for integer types")
	}
	switch flavor {
	case flavors.MySQL:
		return sqlType + " AUTO_INCREMENT"
	case flavors.PostgreSQL:
		switch col.AbstractType {
		case ColumnTypeSmallInt:
			return "SMALLSERIAL"
		case ColumnTypeInt:
			return "SERIAL"
		case ColumnTypeBigInt:
			return "BIGSERIAL"
		default:
			return sqlType + " GENERATED BY DEFAULT AS IDENTITY"
		}
	case flavors.SQLite:
		return "INTEGER PRIMARY KEY AUTOINCREMENT"
	case flavors.SQLServer:
		return sqlType + " IDENTITY(1,1)"
	case flavors.Oracle:
		return sqlType + " GENERATED ALWAYS AS IDENTITY"
	case flavors.Informix:
		switch col.AbstractType {
		case ColumnTypeInt:
			return "SERIAL"
		case ColumnTypeBigInt:
			return "BIGSERIAL"
		default:
			return sqlType
		}
	case flavors.CQL, flavors.ClickHouse, flavors.Presto:
		panic(fmt.Sprintf("auto-increment not supported for flavor: %s", flavor))
	default:
		panic(fmt.Sprintf("unsupported flavor for auto-increment: %s", flavor))
	}
}

// formatDefault formats the default value as SQL string.
func formatDefault(flavor flavors.Flavor, v any) string {
	if v == nil {
		return "NULL"
	}
	rv := reflect.ValueOf(v)
	kind := rv.Kind()
	if kind >= reflect.Int && kind <= reflect.Int64 {
		return fmt.Sprint(rv.Int())
	}
	if kind >= reflect.Uint && kind <= reflect.Uint64 {
		return fmt.Sprint(rv.Uint())
	}
	if kind == reflect.Float32 || kind == reflect.Float64 {
		return fmt.Sprint(rv.Float())
	}
	if kind == reflect.Bool {
		b := rv.Bool()
		switch flavor {
		case flavors.PostgreSQL, flavors.CQL, flavors.ClickHouse, flavors.Presto, flavors.Oracle, flavors.Informix:
			if b {
				return "TRUE"
			}
			return "FALSE"
		default:
			if b {
				return "1"
			}
			return "0"
		}
	}
	if kind == reflect.String {
		escaped := strings.Replace(rv.String(), "'", "''", -1)
		return "'" + escaped + "'"
	}
	if t, ok := v.(time.Time); ok {
		return "'" + t.Format("2006-01-02 15:04:05") + "'"
	}
	if b, ok := v.([]byte); ok {
		var buf bytes.Buffer
		buf.WriteString("X'")
		for _, byteVal := range b {
			fmt.Fprintf(&buf, "%02X", byteVal)
		}
		buf.WriteString("'")
		return buf.String()
	}
	panic(fmt.Sprintf("unsupported default type: %T", v))
}

// BuildCreate builds the CREATE TABLE SQL for the given flavor.
func (t *Table) BuildCreate(flavor flavors.Flavor) string {
	builder := flavors.NewCreateTableBuilder(flavor)
	builder.CreateTable(flavor.Quote(t.Name))
	for _, col := range t.Columns {
		sqlType := getTypeWithAuto(flavor, col)
		def := flavor.Quote(col.Name) + " " + sqlType
		if col.HasDefault {
			def += " DEFAULT " + formatDefault(flavor, col.Default)
		}
		builder.Define(def)
	}
	sql, _ := builder.Build()
	return sql
}
